<!DOCTYPE html>
<html>
<head>
    <script src="js/easeljs-0.8.2.min.js"></script>
    <script src="tile.js"></script>
    <script src="wall_grid.js"></script>
	<script src="lock_grid.js"></script>
    <script>
        function init() {
            
			//initial setup variables
			var team_a_starting_clones_left = 5;
			var team_b_starting_clones_left = 5;
			
            var scale;
            var stage = new createjs.Stage("game_board");
			var board_bg = new createjs.Bitmap("images/medium_board.png");
			var fade_base_rate = 5;
			
			window.onresize = function(){ onResize(); }
			stage.enableMouseOver(20);
			createjs.Ticker.addEventListener("tick", stage);
			createjs.Ticker.addEventListener("tick", update_fades);            
            stage.addChild(board_bg);
            onResize();
			
            var tile_size = 70;			
			var board_width = 31;
            var board_height = 21;
			var tile_start_x = 83;
            var tile_start_y = 78;
            var tile_gap = (board_bg.image.naturalWidth - tile_start_x * 2)/ board_width - tile_size -1.6;
            
            function coords_to_pixels(x, y) {
                return_x = tile_start_x + (x * (tile_size+tile_gap));
                return_y = tile_start_y + (y * (tile_size+tile_gap));
                var return_array = [return_x,return_y];
                return return_array;
            }
            
            var first_tile = new Tile();
			var tiles = {};
            
            for(var tile_col = 0; tile_col < board_width; tile_col++)
            {
                for(var tile_row = 0; tile_row < board_height; tile_row++)
                {
                    var current_tile = first_tile.clone(true);
					
					current_tile.name = "tile_"+tile_col+"_"+tile_row;
                    current_tile.coord_x = tile_col;
                    current_tile.coord_y = tile_row;
					
                    current_tile.graphics.beginFill(createjs.Graphics.getRGB(255, 255, 255));
					current_tile.alpha = 0;
                    
                    current_tile.graphics.drawRoundRect(tile_size / 2,tile_size / 2,tile_size,tile_size,10);
                     
					current_tile.x = coords_to_pixels(tile_col,tile_row)[0];
					current_tile.y = coords_to_pixels(tile_col,tile_row)[1];
					
					current_tile.hitArea = new createjs.Shape(new createjs.Graphics().beginFill("#f00").drawRect(tile_size / 2,tile_size / 2,tile_size+tile_gap,tile_size+tile_gap));
					//current_tile.on("rollover", function(evt){is_fading_in[evt.target.name] = true;});
					//current_tile.on("rollout", function(evt){is_fading_in[evt.target.name] = false;});
                    
                    current_tile.on("click", function(evt) {
						//add_initial_clone(evt.target.coord_x,evt.target.coord_y);
						//show(team_a_starting_clones_left);
						show(LOCK_GRID[evt.target.coord_x][evt.target.coord_y]);
						show(evt.target.coord_x + ", " + evt.target.coord_y);
						
					});
                    tiles[current_tile.name]=current_tile;
                    stage.addChild(current_tile);
                }
            }
            
			
			//draw clone test block for traversal testing
            first_tile.graphics.beginFill(createjs.Graphics.getRGB(0, 0, 255, 1));
            first_tile.graphics.beginStroke(createjs.Graphics.getRGB(0, 0, 255, 0));
            first_tile.graphics.setStrokeStyle(1);
			first_tile.shadow = new createjs.Shadow("#000", 3, 3, 6);
                            
            first_tile.graphics.drawRoundRect(tile_size / 2,tile_size / 2,tile_size,tile_size,10);
            first_tile.coord_x = 0;
            first_tile.coord_y = 0;
            first_tile.x = coords_to_pixels(first_tile.coord_x,first_tile.coord_y)[0];
            first_tile.y = coords_to_pixels(first_tile.coord_x,first_tile.coord_y)[1];
            
            first_tile.on("click", function(evt) {});
            //stage.addChild(first_tile);
			
			//END OF CLONE TRAVERSAL TESTING
			
			function add_initial_clone(x, y)
			{
				if(team_a_starting_clones_left == 0 || typeof x == 'undefined')
					return false;
					
				var new_clone = first_tile.clone(true);
				new_clone.name = "clone_a_"+x+"_"+y;
				new_clone.coord_x = x;
				new_clone.coord_y = y;
				
				new_clone.graphics.beginFill(createjs.Graphics.getRGB(255, 255, 255));
				
				new_clone.graphics.drawRoundRect(tile_size / 2,tile_size / 2,tile_size,tile_size,10);
				 
				new_clone.x = coords_to_pixels(x,y)[0];
				new_clone.y = coords_to_pixels(x,y)[1];
				
				new_clone.hitArea = new createjs.Shape(new createjs.Graphics().beginFill("#f00").drawRect(tile_size / 2,tile_size / 2,tile_size+tile_gap,tile_size+tile_gap));
				//current_tile.on("rollover", function(evt){is_fading_in[evt.target.name] = true;});
				//current_tile.on("rollout", function(evt){is_fading_in[evt.target.name] = false;});
				
				new_clone.on("click", function(evt) {
					add_initial_clone();
					show(evt.target.coord_x + ", " + evt.target.coord_y);
					show(team_a_starting_clones_left);
				});
				tiles[new_clone.name]=new_clone;
				
				
				
				stage.addChild(new_clone);
				team_a_starting_clones_left--;
				stage.update();
			}
			
			// Build resource tiles
			var first_resource_cylinder = new createjs.Shape();
			var resource_cylinders = {};
            //top resources
            for(var tile_row = 0; tile_row < 5; tile_row++)
            {
                for(var tile_col = 2; tile_col < 6; tile_col++)
                {
                    var cyl = first_resource_cylinder.clone(true);
					
					cyl.name = "resource"+tile_row+"_"+tile_col;
                    cyl.coord_x = tile_col;
                    cyl.coord_y = tile_row;
					switch(tile_col)
					{
						case 2:
							cyl.graphics.beginFill(createjs.Graphics.getRGB(255, 255, 0, .75));
							cyl.graphics.beginStroke(createjs.Graphics.getRGB(0, 0, 0, 1));
							break;
							
						case 3:
							cyl.graphics.beginFill(createjs.Graphics.getRGB(255, 255, 255, .75));
							cyl.graphics.beginStroke(createjs.Graphics.getRGB(0, 0, 0, 1));
							break;
						
						case 4:
							cyl.graphics.beginFill(createjs.Graphics.getRGB(255, 0, 0, .75));
							cyl.graphics.beginStroke(createjs.Graphics.getRGB(0, 0, 0, 1));
							break;
						
						case 5:
							cyl.graphics.beginFill(createjs.Graphics.getRGB(0, 0, 255, .75));
							cyl.graphics.beginStroke(createjs.Graphics.getRGB(0, 0, 0, 1));
							break;
					}
					cyl.shadow = new createjs.Shadow("#000", 5, 5, 10);
                    
					cyl.graphics.setStrokeStyle(2);
                    cyl.graphics.drawCircle(tile_size,tile_size,tile_size/2);
                     
					cyl.x = coords_to_pixels(tile_col,tile_row)[0];
					cyl.y = coords_to_pixels(tile_col,tile_row)[1];
                    cyl.on("click", function(evt) {show(evt.target.coord_x + ", " + evt.target.coord_y);});
                    resource_cylinders[cyl.name]=cyl;
					
                    stage.addChild(cyl);
                }
            }
			
			//bottom resources
            for(var tile_row = 20; tile_row > 15; tile_row--)
            {
                for(var tile_col = 2; tile_col < 6; tile_col++)
                {
                    var cyl = first_resource_cylinder.clone(true);
					
					cyl.name = "resource"+tile_row+"_"+tile_col;
                    cyl.coord_x = tile_col;
                    cyl.coord_y = tile_row;
					switch(tile_col)
					{
						case 2:
							cyl.graphics.beginFill(createjs.Graphics.getRGB(255, 255, 0, .75));
							cyl.graphics.beginStroke(createjs.Graphics.getRGB(0, 0, 0, 1));
							break;
							
						case 3:
							cyl.graphics.beginFill(createjs.Graphics.getRGB(255, 165, 0, .75));
							cyl.graphics.beginStroke(createjs.Graphics.getRGB(0, 0, 0, 1));
							break;
						
						case 4:
							cyl.graphics.beginFill(createjs.Graphics.getRGB(160, 32, 240, .75));
							cyl.graphics.beginStroke(createjs.Graphics.getRGB(0, 0, 0, 1));
							break;
						
						case 5:
							cyl.graphics.beginFill(createjs.Graphics.getRGB(0, 255, 0, .75));
							cyl.graphics.beginStroke(createjs.Graphics.getRGB(0, 0, 0, 1));
							break;
					}
					cyl.shadow = new createjs.Shadow("#000", 5, 5, 10);
                    
					cyl.graphics.setStrokeStyle(2);
                    cyl.graphics.drawCircle(tile_size,tile_size,tile_size/2);
                     
					cyl.x = coords_to_pixels(tile_col,tile_row)[0];
					cyl.y = coords_to_pixels(tile_col,tile_row)[1];
                    cyl.on("click", function(evt) {show(evt.target.coord_x + ", " + evt.target.coord_y);});
                    resource_cylinders[cyl.name]=cyl;
					
                    stage.addChild(cyl);
                }
            }
			
			
			
			
			
            
            document.onkeydown = handleKeyDown;
            document.onkeyup = handleKeyUp;
            document.onmousedown = handleKeyDown;
            document.onmouseup = handleKeyUp;
            
            stage.onmousemove = onMouseMove;


            // on mouse move, update the stage's mouseX/mouseY:
            function onMouseMove(e) {
                if(!e){ e = window.event; }
                stage.mouseX = e.pageX-canvas.offsetLeft;
                stage.mouseY = e.pageY-canvas.offsetTop;
            }
            
            // scale Display Objects on mouseOver / Out:
			
            /* function onMouseOver(target){
			if(!(target instanceof createjs.Bitmap)){
				show(target.alpha);
                target.alpha = target.alpha*=0.85;                
				}
            }
			
			function onMouseOut(target){
				if(!(target instanceof createjs.Bitmap)){
					while(target.alpha < 1)
					{
						show(target.alpha);
						if(target.alpha * 1.1 <=1)
							target.alpha = target.alpha*=1.1;  
						else
							target.alpha = 1;
					}              
				}
            } */
            
            function handleKeyUp(e)
            {
                
            }
            function handleKeyDown(e)
            {
                switch (e.which || e.keyCode){
                    case 38: //UP
                        show("test " + WALL_GRID[first_tile.coord_x][first_tile.coord_y] + " :: "+ parseInt(WALL_GRID[first_tile.coord_x][first_tile.coord_y]&1));
                        if (parseInt(WALL_GRID[first_tile.coord_x][first_tile.coord_y]&1) == 0) {
                            first_tile.coord_y--;
                            first_tile.y = coords_to_pixels(first_tile.coord_x,first_tile.coord_y)[1];
                        }
                        break;
                    case 40: //DOWN
                        show("test " + WALL_GRID[first_tile.coord_x][first_tile.coord_y] + " :: "+ parseInt(WALL_GRID[first_tile.coord_x][first_tile.coord_y]&4));
                        if (parseInt(WALL_GRID[first_tile.coord_x][first_tile.coord_y]&4) == 0) {
                            first_tile.coord_y++;
                            first_tile.y = coords_to_pixels(first_tile.coord_x,first_tile.coord_y)[1];
                        }
                        break;
                    case 39: // right arrow key
                        show("test " + WALL_GRID[first_tile.coord_x][first_tile.coord_y] + " :: "+ parseInt(WALL_GRID[first_tile.coord_x][first_tile.coord_y]&2));
                        if (parseInt(WALL_GRID[first_tile.coord_x][first_tile.coord_y]&2) == 0) {
                            first_tile.coord_x++;
                            first_tile.x = coords_to_pixels(first_tile.coord_x,first_tile.coord_x)[0];
                        }
                        break;
                    case 37: // left arrow key
                        show("test " + WALL_GRID[first_tile.coord_x][first_tile.coord_y] + " :: "+ parseInt(WALL_GRID[first_tile.coord_x][first_tile.coord_y]&8));
                        if (parseInt(WALL_GRID[first_tile.coord_x][first_tile.coord_y]&8) == 0) {
                            first_tile.coord_x--;
                            first_tile.x = coords_to_pixels(first_tile.coord_x,first_tile.coord_x)[0];
                        }
                        break;
                }
            }
			
			var is_fading_in = {};
			
			function update_fades(event){
			
				for(fading_shape in is_fading_in)
				{
					//show(tiles[fading_shape].alpha);
					if(is_fading_in[fading_shape] == true)
					{
						tiles[fading_shape].alpha += Math.abs(tiles[fading_shape].alpha - 1) / fade_base_rate;
						if(Math.round(tiles[fading_shape].alpha/0.1) >= 10)
							tiles[fading_shape].alpha = 1;
					}
					else
					{
						tiles[fading_shape].alpha += (0 - tiles[fading_shape].alpha) / fade_base_rate;
							if(Math.round(tiles[fading_shape].alpha/0.01) <= 0){
							tiles[fading_shape].alpha = 0;
							delete is_fading_in[fading_shape];
						}
					}
				}
			}
			
			var legal_moves = [];
			show("Legal Moves (15,2,10): ");
			show(get_legal_move(15,2,10));
			//get_legal_move(1,1,1);
			function get_legal_move(spaces, original_x, original_y, prev_x, prev_y)
			{
				//show ("spaces "+spaces);
				//show ("orig coords "+original_x + ", " + original_y + ":: prev coords "+prev_x + ", " +prev_y);
				//show ("orig coords wall value " + WALL_GRID[original_x][original_y]);
				 
				var directions_available = [1,2,4,8],
				available_direction_to_axis_change = {
					'1':{'y': parseInt(-1)},
					'2':{'x': parseInt(1)},
					'4':{'y': parseInt(1)},
					'8':{'x': parseInt(-1)}
					};
				
				
				spaces--;
				if(LOCK_GRID[original_x][original_y] && !LOCK_GRID[prev_x][prev_y])
				{
					//show("found a lock with " + spaces + " spaces remaining! "+original_x+ ", " + original_y);
					//show(get_local_locks(original_x,original_y));
					var locks = get_local_locks(original_x,original_y);
					for(lock in locks)
					{
					if((locks[lock][0] != prev_x || locks[lock][1] != prev_y)) {
						
							if(spaces == 0){
								//show("zero spaces left! orig "+original_x + ", " +original_y);
								legal_moves.push([parseInt(locks[lock][0]),parseInt(locks[lock][1])]);
							}else{
								get_legal_move(spaces,parseInt(locks[lock][0]),parseInt(locks[lock][1]),original_x,original_y);
							}
						}
					}
				}
				for(direction in directions_available)
				{			
					if(parseInt(WALL_GRID[original_x][original_y] & directions_available[direction]) == 0)
					{
						//show("wall check on " + original_x + ", " + original_y + " for "+ directions_available[direction] + ":: "+parseInt(WALL_GRID[original_x][original_y] & directions_available[direction]));
						if(typeof available_direction_to_axis_change[directions_available[direction]].x != 'undefined'
						&& original_x + available_direction_to_axis_change[directions_available[direction]].x != prev_x) {
							
							//show("X:: "+available_direction_to_axis_change[directions_available[direction]].x );
							//show("Y:: "+available_direction_to_axis_change[directions_available[direction]].y );
							if(spaces == 0){
								legal_moves.push([original_x + available_direction_to_axis_change[directions_available[direction]].x,original_y]);
							}else{
								get_legal_move(spaces,original_x + available_direction_to_axis_change[directions_available[direction]].x,original_y, original_x, original_y);
								}
						}
						
						if(typeof available_direction_to_axis_change[directions_available[direction]].y != 'undefined'
						&& original_y + available_direction_to_axis_change[directions_available[direction]].y != prev_y) {
							
							//show("Y:: "+available_direction_to_axis_change[directions_available[direction]].y );
							if(spaces == 0){
								legal_moves.push([original_x,original_y + available_direction_to_axis_change[directions_available[direction]].y]);
							}else{
								get_legal_move(spaces,original_x,original_y + available_direction_to_axis_change[directions_available[direction]].y, original_x, original_y);
								}
						}
						//show(available_direction_to_axis_change[directions_available[direction]]);						
					}
				}
				return legal_moves;
			}
			
			function get_local_locks(this_lock_x,this_lock_y)
			{
				if(LOCK_GRID[this_lock_x][this_lock_y] != 1)
					return 0;
					
				var return_obj = [];
				
				for(col in LOCK_GRID)
				{
					if((this_lock_x <15 && col > 15) || (this_lock_x >15 && col < 15)) 
						continue;
						
					for(row in LOCK_GRID[col])
					{
						if(LOCK_GRID[col][row]==1 && (this_lock_x != col || this_lock_y != row))
						{
							
							return_obj.push([col,row]);
						}
					}
				}
				
				return return_obj;
				
			}
			
			function show(what) {
                console.log(what);
            }
			
			function onResize()
			{
				// browser viewport size
				var w = document.documentElement.clientWidth;
				var h = document.documentElement.clientHeight-5;
				
				stage_height = h;
				stage_width = h * board_bg.image.naturalWidth / board_bg.image.naturalHeight;
				
				scale = Math.min(stage_height / board_bg.image.naturalHeight, stage_width / board_bg.image.naturalWidth);
				
				stage.scaleX = stage.scaleY = scale;
				
				stage.canvas.height = h;
				stage.canvas.width = w;
				stage.update()
				
			}
            
            function tick() {
                //show(stage.getObjectUnderPoint(stage.mouseX, stage.mouseY));
                // if we were dragging, but are not anymore, call mouseOut with the old target:
                //if(mouseTarget){ 
                //    onMouseOut(mouseTarget);
                //}
                // if we're not currently dragging, and have valid mouseX and mouseY values, check for objects under mouse:
                if(stage.mouseX && stage.mouseY){
                    // when running local files, most browsers throw a security error when reading pixel data
                    // (which getObjectUnderPoint uses) so we'll put it in a try/catch block:
                
                    var t = (new Date()).getTime();
                        mouseTarget = stage.getObjectUnderPoint(stage.mouseX, stage.mouseY);
                    try {
                        // this will return the top-most display object under the mouse position:
                    } catch (e) {
                        Ticker.removeListener(window);
                        alert("An error occurred because this browser does not support reading pixel data in local files. Please read 'SECURITY_ERROR_README.txt' included with the EaselJS for details");
                    }
                    if(mouseTarget){
                        // if we found a target, call mouseOver with it:
                        //onMouseOver(mouseTarget);
						//onMouseOut(mouseTarget);
                        //offset.x = mouseTarget.x-stage.mouseX;
                        //offset.y = mouseTarget.y-stage.mouseY;
                    }
                }
                
                
                //Update the display list (draw everything)
                stage.update();

            }
        }
    </script>
</head>
<body onLoad="init();" style="padding:0; margin:0;" >
    <canvas id="game_board" style="padding:0; margin:0;" >
        alternate content
    </canvas>
</body>
</html>
